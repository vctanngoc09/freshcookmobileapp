<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/freshcookapp/ui/screen/detail/RecipeDetailViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/freshcookapp/ui/screen/detail/RecipeDetailViewModel.kt" />
              <option name="originalContent" value="package com.example.freshcookapp.ui.screen.detail&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.freshcookapp.data.local.entity.RecipeEntity&#10;import com.example.freshcookapp.data.repository.RecipeRepository&#10;import com.example.freshcookapp.domain.model.Author&#10;import com.example.freshcookapp.domain.model.InstructionStep&#10;import com.example.freshcookapp.domain.model.Recipe&#10;import com.example.freshcookapp.domain.model.RecipePreview&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FieldValue&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.Query&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.launch&#10;import com.example.freshcookapp.data.repository.CommentRepository&#10;import com.example.freshcookapp.domain.model.Comment&#10;import java.util.Date&#10;&#10;class RecipeDetailViewModel(&#10;    private val repository: RecipeRepository,&#10;    private val commentRepository: CommentRepository&#10;) : ViewModel() {&#10;&#10;    private val firestore = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _recipe = MutableStateFlow&lt;Recipe?&gt;(null)&#10;    val recipe: StateFlow&lt;Recipe?&gt; = _recipe&#10;&#10;    private val _isFollowingAuthor = MutableStateFlow(false)&#10;    val isFollowingAuthor: StateFlow&lt;Boolean&gt; = _isFollowingAuthor&#10;&#10;    private val _comments = MutableStateFlow&lt;List&lt;Comment&gt;&gt;(emptyList())&#10;    val comments: StateFlow&lt;List&lt;Comment&gt;&gt; = _comments&#10;&#10;    private val _commentText = MutableStateFlow(&quot;&quot;)&#10;    val commentText: StateFlow&lt;String&gt; = _commentText&#10;&#10;    private val _hasUnreadNotifications = MutableStateFlow(false)&#10;    val hasUnreadNotifications: StateFlow&lt;Boolean&gt; = _hasUnreadNotifications&#10;&#10;    private val _replyingToUser = MutableStateFlow&lt;String?&gt;(null)&#10;    val replyingToUser: StateFlow&lt;String?&gt; = _replyingToUser&#10;&#10;    init {&#10;        listenToUnreadNotifications()&#10;    }&#10;&#10;    private fun listenToUnreadNotifications() {&#10;        val currentUserId = auth.currentUser?.uid ?: return&#10;        firestore.collection(&quot;users&quot;).document(currentUserId)&#10;            .collection(&quot;notifications&quot;)&#10;            .whereEqualTo(&quot;isRead&quot;, false)&#10;            .addSnapshotListener { snapshot, e -&gt;&#10;                if (e == null &amp;&amp; snapshot != null) {&#10;                    _hasUnreadNotifications.value = snapshot.size() &gt; 0&#10;                }&#10;            }&#10;    }&#10;&#10;    fun loadRecipe(recipeId: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                // 1. Load Local (Hiển thị ngay lập tức)&#10;                val localEntity = repository.getRecipeById(recipeId)&#10;&#10;                if (localEntity != null) {&#10;                    repository.addToRecentlyViewed(recipeId)&#10;                    val relatedEntities = repository.getRelatedRecipes(localEntity.categoryId, localEntity.id).first()&#10;                    val relatedList = relatedEntities.map { entity -&gt;&#10;                        RecipePreview(&#10;                            id = entity.id,&#10;                            title = entity.name,&#10;                            time = &quot;${entity.timeCook} phút&quot;,&#10;                            author = &quot;&quot;,&#10;                            imageUrl = entity.imageUrl,&#10;                            isFavorite = entity.isFavorite&#10;                        )&#10;                    }&#10;&#10;                    _recipe.value = localEntity.toUiModel(&#10;                        Author(localEntity.userId, &quot;Đang tải...&quot;, null),&#10;                        relatedList,&#10;                        localEntity.likeCount&#10;                    )&#10;&#10;                    // 2. Lắng nghe thay đổi từ Room (Local)&#10;                    //  QUAN TRỌNG: Đã sửa logic ghi đè dữ liệu tại đây&#10;                    viewModelScope.launch {&#10;                        repository.getRecipeFlow(recipeId).collect { updatedEntity -&gt;&#10;                            if (updatedEntity != null) {&#10;                                val currentAuthor = _recipe.value?.author ?: Author(updatedEntity.userId, &quot;Đang tải...&quot;, null)&#10;&#10;                                //  GIỮ LẠI DỮ LIỆU ĐÃ TẢI TỪ FIREBASE&#10;                                val currentVideoUrl = _recipe.value?.videoUrl&#10;                                val currentIngredients = _recipe.value?.ingredients ?: emptyList()&#10;                                val currentInstructions = _recipe.value?.instructions ?: emptyList()&#10;&#10;                                // Chỉ cập nhật những thứ Local quản lý (Tim, Tên, Ảnh chính...), giữ nguyên chi tiết&#10;                                val tempRecipe = updatedEntity.toUiModel(&#10;                                    currentAuthor,&#10;                                    relatedList,&#10;                                    updatedEntity.likeCount&#10;                                )&#10;&#10;                                // Nếu đã có dữ liệu chi tiết từ Firebase, hãy giữ lại nó!&#10;                                _recipe.value = tempRecipe.copy(&#10;                                    videoUrl = currentVideoUrl,&#10;                                    ingredients = if (currentIngredients.isNotEmpty()) currentIngredients else tempRecipe.ingredients,&#10;                                    instructions = if (currentInstructions.isNotEmpty()) currentInstructions else tempRecipe.instructions&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    if (localEntity.userId.isNotBlank()) {&#10;                        fetchAuthorInfo(localEntity.userId) { author -&gt;&#10;                            _recipe.value = _recipe.value?.copy(author = author)&#10;                            checkFollowStatus(localEntity.userId)&#10;                        }&#10;                    }&#10;&#10;                    // 3. Load Video &amp; Likes Realtime&#10;                    firestore.collection(&quot;recipes&quot;).document(recipeId)&#10;                        .addSnapshotListener { snapshot, _ -&gt;&#10;                            if (snapshot != null &amp;&amp; snapshot.exists()) {&#10;                                val liveLikeCount = snapshot.getLong(&quot;likeCount&quot;)?.toInt() ?: 0&#10;                                val firestoreUserId = snapshot.getString(&quot;userId&quot;)&#10;                                val liveVideoUrl = snapshot.getString(&quot;videoUrl&quot;)&#10;&#10;                                _recipe.value = _recipe.value?.copy(&#10;                                    likeCount = liveLikeCount,&#10;                                    videoUrl = liveVideoUrl&#10;                                )&#10;&#10;                                if (!firestoreUserId.isNullOrBlank() &amp;&amp; (_recipe.value?.author?.id.isNullOrBlank() || _recipe.value?.author?.id != firestoreUserId)) {&#10;                                    fetchAuthorInfo(firestoreUserId) { author -&gt;&#10;                                        _recipe.value = _recipe.value?.copy(author = author)&#10;                                        checkFollowStatus(firestoreUserId)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                    // 4. Load Instructions (List ảnh) - CÓ GẮN LOG DEBUG&#10;                    firestore.collection(&quot;recipes&quot;).document(recipeId)&#10;                        .collection(&quot;instruction&quot;)&#10;                        .orderBy(&quot;step&quot;, Query.Direction.ASCENDING)&#10;                        .get()&#10;                        .addOnSuccessListener { snapshot -&gt;&#10;                            Log.d(&quot;RecipeDebug&quot;, &quot;================= BẮT ĐẦU LOAD BƯỚC LÀM =================&quot;)&#10;                            Log.d(&quot;RecipeDebug&quot;, &quot;Recipe ID: $recipeId&quot;)&#10;&#10;                            if (!snapshot.isEmpty) {&#10;                                Log.d(&quot;RecipeDebug&quot;, &quot;Tìm thấy ${snapshot.size()} bước làm.&quot;)&#10;&#10;                                val fullSteps = snapshot.documents.mapIndexed { index, doc -&gt;&#10;                                    val stepNum = doc.getLong(&quot;step&quot;)?.toInt() ?: (index + 1)&#10;                                    Log.d(&quot;RecipeDebug&quot;, &quot;--- Đang xử lý Bước $stepNum (Doc ID: ${doc.id}) ---&quot;)&#10;&#10;                                    // 1. Kiểm tra ảnh đơn (imageUrl)&#10;                                    val singleImage = doc.getString(&quot;imageUrl&quot;)&#10;                                    Log.d(&quot;RecipeDebug&quot;, &quot;   + Ảnh đơn (imageUrl): $singleImage&quot;)&#10;&#10;                                    // 2. Kiểm tra danh sách ảnh (imageUrls) lấy trực tiếp từ Firestore&#10;                                    val rawImageUrls = doc.get(&quot;imageUrls&quot;)&#10;                                    Log.d(&quot;RecipeDebug&quot;, &quot;   + Dữ liệu thô 'imageUrls' từ Firestore: Kiểu=${rawImageUrls?.javaClass?.simpleName}, Giá trị=$rawImageUrls&quot;)&#10;&#10;                                    // 3. Ép kiểu an toàn sang List&lt;String&gt;&#10;                                    val imgUrlsList = if (rawImageUrls is List&lt;*&gt;) {&#10;                                        // Lọc chỉ lấy những phần tử là String và không rỗng&#10;                                        rawImageUrls.filterIsInstance&lt;String&gt;().filter { it.isNotBlank() }&#10;                                    } else {&#10;                                        Log.w(&quot;RecipeDebug&quot;, &quot;   ! CẢNH BÁO: 'imageUrls' không phải là List hoặc bị null.&quot;)&#10;                                        emptyList()&#10;                                    }&#10;&#10;                                    Log.d(&quot;RecipeDebug&quot;, &quot;   -&gt; Danh sách ảnh sau khi xử lý (List&lt;String&gt;): $imgUrlsList (Số lượng: ${imgUrlsList.size})&quot;)&#10;&#10;                                    InstructionStep(&#10;                                        stepNumber = stepNum,&#10;                                        description = doc.getString(&quot;description&quot;) ?: &quot;&quot;,&#10;                                        imageUrl = singleImage, // Ảnh đại diện bước&#10;                                        imageUrls = imgUrlsList // List ảnh phụ&#10;                                    )&#10;                                }&#10;                                _recipe.value = _recipe.value?.copy(instructions = fullSteps)&#10;                                Log.d(&quot;RecipeDebug&quot;, &quot;Đã cập nhật ${fullSteps.size} bước vào ViewModel.&quot;)&#10;                            } else {&#10;                                Log.w(&quot;RecipeDebug&quot;, &quot;Không tìm thấy bước làm nào (Collection 'instruction' rỗng).&quot;)&#10;                            }&#10;                            Log.d(&quot;RecipeDebug&quot;, &quot;================= KẾT THÚC LOAD BƯỚC LÀM =================&quot;)&#10;                        }&#10;                        .addOnFailureListener { e -&gt;&#10;                            Log.e(&quot;RecipeDebug&quot;, &quot;LỖI khi tải các bước làm: ${e.message}&quot;, e)&#10;                        }&#10;                    // Load Ingredients&#10;                    firestore.collection(&quot;recipes&quot;).document(recipeId)&#10;                        .collection(&quot;recipeIngredients&quot;)&#10;                        .get()&#10;                        .addOnSuccessListener { snapshot -&gt;&#10;                            if (!snapshot.isEmpty) {&#10;                                val ingredientsList = snapshot.documents.mapNotNull { doc -&gt;&#10;                                    val name = doc.getString(&quot;name&quot;) ?: &quot;&quot;&#10;                                    val quantity = doc.getString(&quot;quantity&quot;) ?: &quot;&quot;&#10;                                    val unit = doc.getString(&quot;unit&quot;) ?: &quot;&quot;&#10;                                    val note = doc.getString(&quot;note&quot;) ?: &quot;&quot;&#10;&#10;                                    // Logic ghép chuỗi: &quot;200 g Thịt bò (thái lát)&quot;&#10;                                    var fullString = name&#10;                                    if (quantity.isNotBlank()) {&#10;                                        fullString = &quot;$quantity $unit $fullString&quot;&#10;                                    }&#10;                                    if (note.isNotBlank()) {&#10;                                        fullString = &quot;$fullString ($note)&quot;&#10;                                    }&#10;                                    fullString.trim()&#10;                                }&#10;                                _recipe.value = _recipe.value?.copy(ingredients = ingredientsList)&#10;                            }&#10;                        }&#10;                }&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun fetchAuthorInfo(authorId: String, onResult: (Author) -&gt; Unit) {&#10;        firestore.collection(&quot;users&quot;).document(authorId).get()&#10;            .addOnSuccessListener { doc -&gt;&#10;                if (doc != null &amp;&amp; doc.exists()) {&#10;                    val name = doc.getString(&quot;fullName&quot;) ?: &quot;Đầu bếp&quot;&#10;                    val avatar = doc.getString(&quot;photoUrl&quot;)&#10;                    onResult(Author(authorId, name, avatar))&#10;                } else {&#10;                    onResult(Author(authorId, &quot;Người dùng không tồn tại&quot;, null))&#10;                }&#10;            }&#10;            .addOnFailureListener { Log.e(&quot;RecipeDetailVM&quot;, &quot;Failed to fetch author info&quot;) }&#10;    }&#10;&#10;    private fun checkIfUserLiked(recipeId: String, onResult: (Boolean) -&gt; Unit) {&#10;        val userId = auth.currentUser?.uid ?: return&#10;        firestore.collection(&quot;users&quot;).document(userId)&#10;            .collection(&quot;favorites&quot;).document(recipeId).get()&#10;            .addOnSuccessListener { onResult(it.exists()) }&#10;            .addOnFailureListener { onResult(false) }&#10;    }&#10;&#10;    fun toggleFavorite() {&#10;        val currentRecipe = _recipe.value ?: return&#10;        val currentUser = auth.currentUser ?: return&#10;        val authorId = currentRecipe.userId ?: currentRecipe.author.id&#10;        if (authorId.isBlank()) return&#10;        val desiredState = !currentRecipe.isFavorite&#10;        viewModelScope.launch {&#10;            repository.toggleFavoriteWithRemote(currentUser.uid, currentRecipe.id, desiredState)&#10;            if (desiredState) sendNotification(authorId, &quot;đã yêu thích món ăn: ${currentRecipe.name}&quot;, currentRecipe.id)&#10;        }&#10;    }&#10;&#10;    fun toggleRelatedFavorite(targetId: String) {&#10;        val currentRecipe = _recipe.value ?: return&#10;        val currentUser = auth.currentUser ?: return&#10;        val targetItem = currentRecipe.relatedRecipes.find { it.id == targetId } ?: return&#10;        val newStatus = !targetItem.isFavorite&#10;        val updatedRelatedList = currentRecipe.relatedRecipes.map { item -&gt;&#10;            if (item.id == targetId) item.copy(isFavorite = newStatus) else item&#10;        }&#10;        _recipe.value = currentRecipe.copy(relatedRecipes = updatedRelatedList)&#10;        viewModelScope.launch {&#10;            repository.toggleFavoriteWithRemote(currentUser.uid, targetId, newStatus)&#10;        }&#10;    }&#10;&#10;    private fun checkFollowStatus(authorId: String) {&#10;        val currentUserId = auth.currentUser?.uid ?: return&#10;        if (currentUserId == authorId || authorId.isBlank()) {&#10;            _isFollowingAuthor.value = false&#10;            return&#10;        }&#10;        firestore.collection(&quot;users&quot;).document(currentUserId).collection(&quot;following&quot;).document(authorId)&#10;            .addSnapshotListener { s, _ -&gt; _isFollowingAuthor.value = s != null &amp;&amp; s.exists() }&#10;    }&#10;&#10;    fun toggleFollowAuthor() {&#10;        val currentUserId = auth.currentUser?.uid ?: return&#10;        val currentRecipe = _recipe.value ?: return&#10;        val authorId = currentRecipe.userId ?: currentRecipe.author.id&#10;        if (currentUserId == authorId || authorId.isBlank()) return&#10;        val currentUserRef = firestore.collection(&quot;users&quot;).document(currentUserId)&#10;        val authorRef = firestore.collection(&quot;users&quot;).document(authorId)&#10;        val followingRef = currentUserRef.collection(&quot;following&quot;).document(authorId)&#10;        val followerRef = authorRef.collection(&quot;followers&quot;).document(currentUserId)&#10;        firestore.runTransaction { transaction -&gt;&#10;            val followingDoc = transaction.get(followingRef)&#10;            if (followingDoc.exists()) {&#10;                transaction.delete(followingRef); transaction.delete(followerRef)&#10;            } else {&#10;                transaction.set(followingRef, mapOf(&quot;timestamp&quot; to FieldValue.serverTimestamp()))&#10;                transaction.set(followerRef, mapOf(&quot;timestamp&quot; to FieldValue.serverTimestamp()))&#10;            }&#10;        }.addOnSuccessListener {&#10;            if (!(_isFollowingAuthor.value)) sendNotification(authorId, &quot;đã bắt đầu theo dõi bạn&quot;, null)&#10;        }.addOnFailureListener { e -&gt; Log.e(&quot;RecipeDetailVM&quot;, &quot;Follow/unfollow transaction FAILED&quot;, e) }&#10;    }&#10;&#10;    private fun sendNotification(receiverId: String, message: String, recipeId: String?) {&#10;        val currentUserId = auth.currentUser?.uid ?: return&#10;        if (currentUserId == receiverId || receiverId.isBlank()) return&#10;        firestore.collection(&quot;users&quot;).document(currentUserId).get().addOnSuccessListener { doc -&gt;&#10;            val noti = hashMapOf(&#10;                &quot;senderId&quot; to currentUserId,&#10;                &quot;senderName&quot; to (doc.getString(&quot;fullName&quot;) ?: &quot;Ai đó&quot;),&#10;                &quot;senderAvatar&quot; to doc.getString(&quot;photoUrl&quot;),&#10;                &quot;message&quot; to message,&#10;                &quot;targetId&quot; to recipeId,&#10;                &quot;timestamp&quot; to FieldValue.serverTimestamp(),&#10;                &quot;isRead&quot; to false,&#10;                &quot;type&quot; to if (recipeId != null) &quot;like&quot; else &quot;follow&quot;&#10;            )&#10;            firestore.collection(&quot;users&quot;).document(receiverId).collection(&quot;notifications&quot;).add(noti)&#10;        }&#10;    }&#10;&#10;    fun updateCommentText(text: String) { _commentText.value = text }&#10;    fun onReplyToComment(username: String) { _replyingToUser.value = username }&#10;    fun onCancelReply() { _replyingToUser.value = null }&#10;&#10;    fun addComment() {&#10;        val rawText = _commentText.value.trim()&#10;        if (rawText.isEmpty()) return&#10;        val user = auth.currentUser ?: return&#10;        val recipe = _recipe.value ?: return&#10;        val authorId = recipe.userId ?: recipe.author.id&#10;        if (authorId.isBlank()) return&#10;        val replyPrefix = _replyingToUser.value?.let { &quot;@$it &quot; } ?: &quot;&quot;&#10;        val finalContent = replyPrefix + rawText&#10;        firestore.collection(&quot;users&quot;).document(user.uid).get().addOnSuccessListener { doc -&gt;&#10;            val avatarUrl = doc.getString(&quot;photoUrl&quot;) ?: user.photoUrl?.toString()&#10;            val comment = Comment(userId = user.uid, recipeId = recipe.id, userName = doc.getString(&quot;fullName&quot;) ?: &quot;User&quot;, userAvatar = avatarUrl, text = finalContent, timestamp = Date())&#10;            viewModelScope.launch {&#10;                if (commentRepository.addComment(comment)) {&#10;                    _commentText.value = &quot;&quot;; _replyingToUser.value = null&#10;                    sendNotification(authorId, &quot;đã bình luận: ${recipe.name}&quot;, recipe.id)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteComment(commentId: String) {&#10;        val recipe = _recipe.value ?: return&#10;        viewModelScope.launch { commentRepository.deleteComment(recipe.id, commentId) }&#10;    }&#10;&#10;    private fun RecipeEntity.toUiModel(author: Author, related: List&lt;RecipePreview&gt;, likes: Int): Recipe {&#10;        return Recipe(&#10;            id = this.id, name = this.name, timeCook = this.timeCook, difficulty = this.difficulty ?: &quot;Trung bình&quot;,&#10;            imageUrl = this.imageUrl, description = this.description ?: &quot;&quot;, author = author, isFavorite = this.isFavorite,&#10;            likeCount = likes, createdAt = this.createdAt, ingredients = this.ingredients ?: emptyList(),&#10;            instructions = this.steps?.mapIndexed { index, s -&gt; InstructionStep(index + 1, s, null) } ?: emptyList(),&#10;            relatedRecipes = related, userId = this.userId&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.freshcookapp.ui.screen.detail&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.freshcookapp.data.local.entity.RecipeEntity&#10;import com.example.freshcookapp.data.repository.RecipeRepository&#10;import com.example.freshcookapp.domain.model.Author&#10;import com.example.freshcookapp.domain.model.InstructionStep&#10;import com.example.freshcookapp.domain.model.Recipe&#10;import com.example.freshcookapp.domain.model.RecipePreview&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FieldValue&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.Query&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.Job&#10;import com.example.freshcookapp.data.repository.CommentRepository&#10;import com.example.freshcookapp.domain.model.Comment&#10;import java.util.Date&#10;&#10;class RecipeDetailViewModel(&#10;    private val repository: RecipeRepository,&#10;    private val commentRepository: CommentRepository&#10;) : ViewModel() {&#10;&#10;    private val firestore = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _recipe = MutableStateFlow&lt;Recipe?&gt;(null)&#10;    val recipe: StateFlow&lt;Recipe?&gt; = _recipe&#10;&#10;    private val _isFollowingAuthor = MutableStateFlow(false)&#10;    val isFollowingAuthor: StateFlow&lt;Boolean&gt; = _isFollowingAuthor&#10;&#10;    private val _comments = MutableStateFlow&lt;List&lt;Comment&gt;&gt;(emptyList())&#10;    val comments: StateFlow&lt;List&lt;Comment&gt;&gt; = _comments&#10;&#10;    private val _commentText = MutableStateFlow(&quot;&quot;)&#10;    val commentText: StateFlow&lt;String&gt; = _commentText&#10;&#10;    private val _hasUnreadNotifications = MutableStateFlow(false)&#10;    val hasUnreadNotifications: StateFlow&lt;Boolean&gt; = _hasUnreadNotifications&#10;&#10;    private val _replyingToUser = MutableStateFlow&lt;String?&gt;(null)&#10;    val replyingToUser: StateFlow&lt;String?&gt; = _replyingToUser&#10;&#10;    // Keep track of which recipeId we're listening comments for and cancel previous listener when switching&#10;    private var commentsListenerRecipeId: String? = null&#10;    private var commentsJob: Job? = null&#10;&#10;    init {&#10;        listenToUnreadNotifications()&#10;    }&#10;&#10;    private fun listenToUnreadNotifications() {&#10;        val currentUserId = auth.currentUser?.uid ?: return&#10;        firestore.collection(&quot;users&quot;).document(currentUserId)&#10;            .collection(&quot;notifications&quot;)&#10;            .whereEqualTo(&quot;isRead&quot;, false)&#10;            .addSnapshotListener { snapshot, e -&gt;&#10;                if (e == null &amp;&amp; snapshot != null) {&#10;                    _hasUnreadNotifications.value = snapshot.size() &gt; 0&#10;                }&#10;            }&#10;    }&#10;&#10;    fun loadRecipe(recipeId: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                // Always start listening to comments for this recipe to support cases&#10;                // where the recipe may not exist locally in Room yet (e.g., opened from a deep link).&#10;                // If we're already listening to this recipe's comments, don't start another collector&#10;                if (commentsListenerRecipeId != recipeId) {&#10;                    // cancel any previous listener&#10;                    commentsJob?.cancel()&#10;                    commentsListenerRecipeId = recipeId&#10;                    commentsJob = viewModelScope.launch {&#10;                        commentRepository.getCommentsForRecipe(recipeId).collect { list -&gt;&#10;                            _comments.value = list&#10;                        }&#10;                    }&#10;                }&#10;                // 1. Load Local (Hiển thị ngay lập tức)&#10;                val localEntity = repository.getRecipeById(recipeId)&#10;&#10;                if (localEntity != null) {&#10;                    repository.addToRecentlyViewed(recipeId)&#10;                    val relatedEntities = repository.getRelatedRecipes(localEntity.categoryId, localEntity.id).first()&#10;                    val relatedList = relatedEntities.map { entity -&gt;&#10;                        RecipePreview(&#10;                            id = entity.id,&#10;                            title = entity.name,&#10;                            time = &quot;${entity.timeCook} phút&quot;,&#10;                            author = &quot;&quot;,&#10;                            imageUrl = entity.imageUrl,&#10;                            isFavorite = entity.isFavorite&#10;                        )&#10;                    }&#10;&#10;                    _recipe.value = localEntity.toUiModel(&#10;                        Author(localEntity.userId, &quot;Đang tải...&quot;, null),&#10;                        relatedList,&#10;                        localEntity.likeCount&#10;                    )&#10;&#10;                    // 2. Lắng nghe thay đổi từ Room (Local)&#10;                    //  QUAN TRỌNG: Đã sửa logic ghi đè dữ liệu tại đây&#10;                    viewModelScope.launch {&#10;                        repository.getRecipeFlow(recipeId).collect { updatedEntity -&gt;&#10;                            if (updatedEntity != null) {&#10;                                val currentAuthor = _recipe.value?.author ?: Author(updatedEntity.userId, &quot;Đang tải...&quot;, null)&#10;&#10;                                //  GIỮ LẠI DỮ LIỆU ĐÃ TẢI TỪ FIREBASE&#10;                                val currentVideoUrl = _recipe.value?.videoUrl&#10;                                val currentIngredients = _recipe.value?.ingredients ?: emptyList()&#10;                                val currentInstructions = _recipe.value?.instructions ?: emptyList()&#10;&#10;                                // Chỉ cập nhật những thứ Local quản lý (Tim, Tên, Ảnh chính...), giữ nguyên chi tiết&#10;                                val tempRecipe = updatedEntity.toUiModel(&#10;                                    currentAuthor,&#10;                                    relatedList,&#10;                                    updatedEntity.likeCount&#10;                                )&#10;&#10;                                // Nếu đã có dữ liệu chi tiết từ Firebase, hãy giữ lại nó!&#10;                                _recipe.value = tempRecipe.copy(&#10;                                    videoUrl = currentVideoUrl,&#10;                                    ingredients = if (currentIngredients.isNotEmpty()) currentIngredients else tempRecipe.ingredients,&#10;                                    instructions = if (currentInstructions.isNotEmpty()) currentInstructions else tempRecipe.instructions&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    if (localEntity.userId.isNotBlank()) {&#10;                        fetchAuthorInfo(localEntity.userId) { author -&gt;&#10;                            _recipe.value = _recipe.value?.copy(author = author)&#10;                            checkFollowStatus(localEntity.userId)&#10;                        }&#10;                    }&#10;&#10;                    // 3. Load Video &amp; Likes Realtime&#10;                    firestore.collection(&quot;recipes&quot;).document(recipeId)&#10;                        .addSnapshotListener { snapshot, _ -&gt;&#10;                            if (snapshot != null &amp;&amp; snapshot.exists()) {&#10;                                val liveLikeCount = snapshot.getLong(&quot;likeCount&quot;)?.toInt() ?: 0&#10;                                val firestoreUserId = snapshot.getString(&quot;userId&quot;)&#10;                                val liveVideoUrl = snapshot.getString(&quot;videoUrl&quot;)&#10;&#10;                                _recipe.value = _recipe.value?.copy(&#10;                                    likeCount = liveLikeCount,&#10;                                    videoUrl = liveVideoUrl&#10;                                )&#10;&#10;                                if (!firestoreUserId.isNullOrBlank() &amp;&amp; (_recipe.value?.author?.id.isNullOrBlank() || _recipe.value?.author?.id != firestoreUserId)) {&#10;                                    fetchAuthorInfo(firestoreUserId) { author -&gt;&#10;                                        _recipe.value = _recipe.value?.copy(author = author)&#10;                                        checkFollowStatus(firestoreUserId)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                    // 4. Load Instructions (List ảnh) - CÓ GẮN LOG DEBUG&#10;                    firestore.collection(&quot;recipes&quot;).document(recipeId)&#10;                        .collection(&quot;instruction&quot;)&#10;                        .orderBy(&quot;step&quot;, Query.Direction.ASCENDING)&#10;                        .get()&#10;                        .addOnSuccessListener { snapshot -&gt;&#10;                            Log.d(&quot;RecipeDebug&quot;, &quot;================= BẮT ĐẦU LOAD BƯỚC LÀM =================&quot;)&#10;                            Log.d(&quot;RecipeDebug&quot;, &quot;Recipe ID: $recipeId&quot;)&#10;&#10;                            if (!snapshot.isEmpty) {&#10;                                Log.d(&quot;RecipeDebug&quot;, &quot;Tìm thấy ${snapshot.size()} bước làm.&quot;)&#10;&#10;                                val fullSteps = snapshot.documents.mapIndexed { index, doc -&gt;&#10;                                    val stepNum = doc.getLong(&quot;step&quot;)?.toInt() ?: (index + 1)&#10;                                    Log.d(&quot;RecipeDebug&quot;, &quot;--- Đang xử lý Bước $stepNum (Doc ID: ${doc.id}) ---&quot;)&#10;&#10;                                    // 1. Kiểm tra ảnh đơn (imageUrl)&#10;                                    val singleImage = doc.getString(&quot;imageUrl&quot;)&#10;                                    Log.d(&quot;RecipeDebug&quot;, &quot;   + Ảnh đơn (imageUrl): $singleImage&quot;)&#10;&#10;                                    // 2. Kiểm tra danh sách ảnh (imageUrls) lấy trực tiếp từ Firestore&#10;                                    val rawImageUrls = doc.get(&quot;imageUrls&quot;)&#10;                                    Log.d(&quot;RecipeDebug&quot;, &quot;   + Dữ liệu thô 'imageUrls' từ Firestore: Kiểu=${rawImageUrls?.javaClass?.simpleName}, Giá trị=$rawImageUrls&quot;)&#10;&#10;                                    // 3. Ép kiểu an toàn sang List&lt;String&gt;&#10;                                    val imgUrlsList = if (rawImageUrls is List&lt;*&gt;) {&#10;                                        // Lọc chỉ lấy những phần tử là String và không rỗng&#10;                                        rawImageUrls.filterIsInstance&lt;String&gt;().filter { it.isNotBlank() }&#10;                                    } else {&#10;                                        Log.w(&quot;RecipeDebug&quot;, &quot;   ! CẢNH BÁO: 'imageUrls' không phải là List hoặc bị null.&quot;)&#10;                                        emptyList()&#10;                                    }&#10;&#10;                                    Log.d(&quot;RecipeDebug&quot;, &quot;   -&gt; Danh sách ảnh sau khi xử lý (List&lt;String&gt;): $imgUrlsList (Số lượng: ${imgUrlsList.size})&quot;)&#10;&#10;                                    InstructionStep(&#10;                                        stepNumber = stepNum,&#10;                                        description = doc.getString(&quot;description&quot;) ?: &quot;&quot;,&#10;                                        imageUrl = singleImage, // Ảnh đại diện bước&#10;                                        imageUrls = imgUrlsList // List ảnh phụ&#10;                                    )&#10;                                }&#10;                                _recipe.value = _recipe.value?.copy(instructions = fullSteps)&#10;                                Log.d(&quot;RecipeDebug&quot;, &quot;Đã cập nhật ${fullSteps.size} bước vào ViewModel.&quot;)&#10;                            } else {&#10;                                Log.w(&quot;RecipeDebug&quot;, &quot;Không tìm thấy bước làm nào (Collection 'instruction' rỗng).&quot;)&#10;                            }&#10;                            Log.d(&quot;RecipeDebug&quot;, &quot;================= KẾT THÚC LOAD BƯỚC LÀM =================&quot;)&#10;                        }&#10;                        .addOnFailureListener { e -&gt;&#10;                            Log.e(&quot;RecipeDebug&quot;, &quot;LỖI khi tải các bước làm: ${e.message}&quot;, e)&#10;                        }&#10;                    // Load Ingredients&#10;                    firestore.collection(&quot;recipes&quot;).document(recipeId)&#10;                        .collection(&quot;recipeIngredients&quot;)&#10;                        .get()&#10;                        .addOnSuccessListener { snapshot -&gt;&#10;                            if (!snapshot.isEmpty) {&#10;                                val ingredientsList = snapshot.documents.mapNotNull { doc -&gt;&#10;                                    val name = doc.getString(&quot;name&quot;) ?: &quot;&quot;&#10;                                    val quantity = doc.getString(&quot;quantity&quot;) ?: &quot;&quot;&#10;                                    val unit = doc.getString(&quot;unit&quot;) ?: &quot;&quot;&#10;                                    val note = doc.getString(&quot;note&quot;) ?: &quot;&quot;&#10;&#10;                                    // Logic ghép chuỗi: &quot;200 g Thịt bò (thái lát)&quot;&#10;                                    var fullString = name&#10;                                    if (quantity.isNotBlank()) {&#10;                                        fullString = &quot;$quantity $unit $fullString&quot;&#10;                                    }&#10;                                    if (note.isNotBlank()) {&#10;                                        fullString = &quot;$fullString ($note)&quot;&#10;                                    }&#10;                                    fullString.trim()&#10;                                }&#10;                                _recipe.value = _recipe.value?.copy(ingredients = ingredientsList)&#10;                            }&#10;                        }&#10;                }&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun fetchAuthorInfo(authorId: String, onResult: (Author) -&gt; Unit) {&#10;        firestore.collection(&quot;users&quot;).document(authorId).get()&#10;            .addOnSuccessListener { doc -&gt;&#10;                if (doc != null &amp;&amp; doc.exists()) {&#10;                    val name = doc.getString(&quot;fullName&quot;) ?: &quot;Đầu bếp&quot;&#10;                    val avatar = doc.getString(&quot;photoUrl&quot;)&#10;                    onResult(Author(authorId, name, avatar))&#10;                } else {&#10;                    onResult(Author(authorId, &quot;Người dùng không tồn tại&quot;, null))&#10;                }&#10;            }&#10;            .addOnFailureListener { Log.e(&quot;RecipeDetailVM&quot;, &quot;Failed to fetch author info&quot;) }&#10;    }&#10;&#10;    private fun checkIfUserLiked(recipeId: String, onResult: (Boolean) -&gt; Unit) {&#10;        val userId = auth.currentUser?.uid ?: return&#10;        firestore.collection(&quot;users&quot;).document(userId)&#10;            .collection(&quot;favorites&quot;).document(recipeId).get()&#10;            .addOnSuccessListener { onResult(it.exists()) }&#10;            .addOnFailureListener { onResult(false) }&#10;    }&#10;&#10;    fun toggleFavorite() {&#10;        val currentRecipe = _recipe.value ?: return&#10;        val currentUser = auth.currentUser ?: return&#10;        val authorId = currentRecipe.userId ?: currentRecipe.author.id&#10;        if (authorId.isBlank()) return&#10;        val desiredState = !currentRecipe.isFavorite&#10;        viewModelScope.launch {&#10;            repository.toggleFavoriteWithRemote(currentUser.uid, currentRecipe.id, desiredState)&#10;            if (desiredState) sendNotification(authorId, &quot;đã yêu thích món ăn: ${currentRecipe.name}&quot;, currentRecipe.id)&#10;        }&#10;    }&#10;&#10;    fun toggleRelatedFavorite(targetId: String) {&#10;        val currentRecipe = _recipe.value ?: return&#10;        val currentUser = auth.currentUser ?: return&#10;        val targetItem = currentRecipe.relatedRecipes.find { it.id == targetId } ?: return&#10;        val newStatus = !targetItem.isFavorite&#10;        val updatedRelatedList = currentRecipe.relatedRecipes.map { item -&gt;&#10;            if (item.id == targetId) item.copy(isFavorite = newStatus) else item&#10;        }&#10;        _recipe.value = currentRecipe.copy(relatedRecipes = updatedRelatedList)&#10;        viewModelScope.launch {&#10;            repository.toggleFavoriteWithRemote(currentUser.uid, targetId, newStatus)&#10;        }&#10;    }&#10;&#10;    private fun checkFollowStatus(authorId: String) {&#10;        val currentUserId = auth.currentUser?.uid ?: return&#10;        if (currentUserId == authorId || authorId.isBlank()) {&#10;            _isFollowingAuthor.value = false&#10;            return&#10;        }&#10;        firestore.collection(&quot;users&quot;).document(currentUserId).collection(&quot;following&quot;).document(authorId)&#10;            .addSnapshotListener { s, _ -&gt; _isFollowingAuthor.value = s != null &amp;&amp; s.exists() }&#10;    }&#10;&#10;    fun toggleFollowAuthor() {&#10;        val currentUserId = auth.currentUser?.uid ?: return&#10;        val currentRecipe = _recipe.value ?: return&#10;        val authorId = currentRecipe.userId ?: currentRecipe.author.id&#10;        if (currentUserId == authorId || authorId.isBlank()) return&#10;        val currentUserRef = firestore.collection(&quot;users&quot;).document(currentUserId)&#10;        val authorRef = firestore.collection(&quot;users&quot;).document(authorId)&#10;        val followingRef = currentUserRef.collection(&quot;following&quot;).document(authorId)&#10;        val followerRef = authorRef.collection(&quot;followers&quot;).document(currentUserId)&#10;        firestore.runTransaction { transaction -&gt;&#10;            val followingDoc = transaction.get(followingRef)&#10;            if (followingDoc.exists()) {&#10;                transaction.delete(followingRef); transaction.delete(followerRef)&#10;            } else {&#10;                transaction.set(followingRef, mapOf(&quot;timestamp&quot; to FieldValue.serverTimestamp()))&#10;                transaction.set(followerRef, mapOf(&quot;timestamp&quot; to FieldValue.serverTimestamp()))&#10;            }&#10;        }.addOnSuccessListener {&#10;            if (!(_isFollowingAuthor.value)) sendNotification(authorId, &quot;đã bắt đầu theo dõi bạn&quot;, null)&#10;        }.addOnFailureListener { e -&gt; Log.e(&quot;RecipeDetailVM&quot;, &quot;Follow/unfollow transaction FAILED&quot;, e) }&#10;    }&#10;&#10;    private fun sendNotification(receiverId: String, message: String, recipeId: String?) {&#10;        val currentUserId = auth.currentUser?.uid ?: return&#10;        if (currentUserId == receiverId || receiverId.isBlank()) return&#10;        firestore.collection(&quot;users&quot;).document(currentUserId).get().addOnSuccessListener { doc -&gt;&#10;            val noti = hashMapOf(&#10;                &quot;senderId&quot; to currentUserId,&#10;                &quot;senderName&quot; to (doc.getString(&quot;fullName&quot;) ?: &quot;Ai đó&quot;),&#10;                &quot;senderAvatar&quot; to doc.getString(&quot;photoUrl&quot;),&#10;                &quot;message&quot; to message,&#10;                &quot;targetId&quot; to recipeId,&#10;                &quot;timestamp&quot; to FieldValue.serverTimestamp(),&#10;                &quot;isRead&quot; to false,&#10;                &quot;type&quot; to if (recipeId != null) &quot;like&quot; else &quot;follow&quot;&#10;            )&#10;            firestore.collection(&quot;users&quot;).document(receiverId).collection(&quot;notifications&quot;).add(noti)&#10;        }&#10;    }&#10;&#10;    fun updateCommentText(text: String) { _commentText.value = text }&#10;    fun onReplyToComment(username: String) { _replyingToUser.value = username }&#10;    fun onCancelReply() { _replyingToUser.value = null }&#10;&#10;    fun addComment() {&#10;        val rawText = _commentText.value.trim()&#10;        if (rawText.isEmpty()) return&#10;        val user = auth.currentUser ?: return&#10;        // Use currently loaded recipe id if available, otherwise fallback to the recipeId we are listening to&#10;        val targetRecipeId = _recipe.value?.id ?: commentsListenerRecipeId ?: return&#10;        val replyPrefix = _replyingToUser.value?.let { &quot;@${it} &quot; } ?: &quot;&quot;&#10;        val finalContent = replyPrefix + rawText&#10;        Log.d(&quot;RecipeDetailVM&quot;, &quot;Adding comment: recipe=$targetRecipeId user=${user.uid} text=$finalContent&quot;)&#10;&#10;        // Get user profile info for display name/avatar&#10;        firestore.collection(&quot;users&quot;).document(user.uid).get().addOnSuccessListener { doc -&gt;&#10;            val avatarUrl = doc.getString(&quot;photoUrl&quot;) ?: user.photoUrl?.toString()&#10;            val userName = doc.getString(&quot;fullName&quot;) ?: &quot;User&quot;&#10;            val comment = Comment(userId = user.uid, recipeId = targetRecipeId, userName = userName, userAvatar = avatarUrl, text = finalContent, timestamp = Date())&#10;&#10;            viewModelScope.launch {&#10;                val ok = commentRepository.addComment(comment)&#10;                Log.d(&quot;RecipeDetailVM&quot;, &quot;addComment result=$ok&quot;)&#10;                if (ok) {&#10;                    // clear input immediately so UI feels responsive&#10;                    _commentText.value = &quot;&quot;&#10;                    _replyingToUser.value = null&#10;&#10;                    // Try to fetch recipe authorId to send notification (best-effort)&#10;                    firestore.collection(&quot;recipes&quot;).document(targetRecipeId).get().addOnSuccessListener { recipeDoc -&gt;&#10;                        val fetchedAuthorId = recipeDoc.getString(&quot;userId&quot;)&#10;                        if (!fetchedAuthorId.isNullOrBlank()) {&#10;                            // avoid notifying self&#10;                            if (fetchedAuthorId != user.uid) sendNotification(fetchedAuthorId, &quot;đã bình luận: ${recipeDoc.getString(&quot;name&quot;) ?: &quot;món ăn&quot;}&quot;, targetRecipeId)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteComment(commentId: String) {&#10;        val recipe = _recipe.value ?: return&#10;        viewModelScope.launch { commentRepository.deleteComment(recipe.id, commentId) }&#10;    }&#10;&#10;    private fun RecipeEntity.toUiModel(author: Author, related: List&lt;RecipePreview&gt;, likes: Int): Recipe {&#10;        return Recipe(&#10;            id = this.id, name = this.name, timeCook = this.timeCook, difficulty = this.difficulty ?: &quot;Trung bình&quot;,&#10;            imageUrl = this.imageUrl, description = this.description ?: &quot;&quot;, author = author, isFavorite = this.isFavorite,&#10;            likeCount = likes, createdAt = this.createdAt, ingredients = this.ingredients ?: emptyList(),&#10;            instructions = this.steps?.mapIndexed { index, s -&gt; InstructionStep(index + 1, s, null) } ?: emptyList(),&#10;            relatedRecipes = related, userId = this.userId&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>